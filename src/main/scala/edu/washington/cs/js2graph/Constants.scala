package edu.washington.cs.js2graph

import com.ibm.wala.cast.js.ipa.summaries.JavaScriptConstructorFunctions
import com.ibm.wala.ipa.callgraph.{CGNode, CallGraph}

import scala.jdk.CollectionConverters._

object Constants {
  val nodeJsBuiltInGlobalNames = Set("process", "console", "document", "Buffer", "eval", "Buffer")

  def isLibraryGlobalName(name: String): Boolean = {
    if (name.startsWith("global ")) {
      val s = name.stripPrefix("global ")
      // FIXME: prefix is not a good heuristic
      nodeJsBuiltInGlobalNames.exists(name => s.startsWith(name))
    } else if (name.startsWith("require(")) {
      true
    } else {
      false
    }
  }

  def asLibraryAPIName(globalBaseName: String, receiverFuncName: String): Option[String] = {
    if (globalBaseName == "global " + WALAGlobalContext) {
      if (nodeJsBuiltInGlobalNames.contains(receiverFuncName)) {
        return Some("global " + receiverFuncName)
      }
    }
    if (isLibraryGlobalName(globalBaseName)) {
      return Some(globalBaseName + "." + receiverFuncName)
    }
    None
  }

  /** Point to global context https://sourceforge.net/p/wala/mailman/message/32491808/
    */
  val WALAGlobalContext = "__WALA__int3rnal__global"

  private val constructorAPIs =
    Map("createElement" -> "HTMLElement", "createDecipher" -> "CryptoDecipher", "toString" -> "String", "execSync" -> "Byte[]")

  /** Whether a function is a API that is essentially an instance constructor
    *
    * If so, we will construct a API instance node during DFA for its return value.
    *
    * FIXME: Consider other APIs as well as the base namespace
    *
    * @return class name
    */
  def getConstructorAPI(funcName: String): Option[String] = constructorAPIs.get(funcName)

  val debug: Option[String] = sys.env.get("DEBUG")

  def isApplicationClassName(className: String): Boolean =
    !className.startsWith("LFakeRoot") && !className.startsWith("Lprologue.js") &&
      !className.startsWith("LObject")

  private val libPkgNames = Set("prologue.js")
  def isLibraryPkgName(pkgName: String): Boolean = libPkgNames.contains(pkgName)

  /** Decide whether a CGNode is a node in application code
    *
    * Some of the CGNodes are generated by analyzer to represent library dependencies etc.
    */
  def isApplicationNode(node: CGNode): Boolean = {
    node.getMethod match {
      case constructor: JavaScriptConstructorFunctions.JavaScriptConstructor =>
        val pkgName = constructor.constructedType().getName.getPackage
        if (pkgName == null) {
          return false
        }
        if (Constants.isLibraryPkgName(pkgName.toString)) {
          return false
        }
      case _ =>
    }
    Constants.isApplicationClassName(node.getMethod.getDeclaringClass.getName.toString)
  }

  def getIRofCG(cg: CallGraph): String = {
    val appNodes = cg.stream().filter(isApplicationNode).iterator().asScala.toList
    val appNodeSuccs = appNodes.flatMap(n => cg.getSuccNodes(n).asScala.filterNot(Constants.isApplicationNode))
    (appNodes ++ appNodeSuccs).map(_.getIR.toString).mkString("\n\n")
  }

  type NodeAttrs = Map[JsNodeAttr.Value, String]
}
