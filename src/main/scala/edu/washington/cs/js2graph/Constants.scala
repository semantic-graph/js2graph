package edu.washington.cs.js2graph

import com.ibm.wala.cast.ir.ssa.{CAstBinaryOp, CAstUnaryOp}
import com.ibm.wala.cast.js.ipa.summaries.JavaScriptConstructorFunctions
import com.ibm.wala.ipa.callgraph.{CGNode, CallGraph}
import com.ibm.wala.shrikeBT.{IBinaryOpInstruction, IUnaryOpInstruction}
import com.semantic_graph.writer.GexfWriter

import scala.jdk.CollectionConverters._

object Constants {
  val unknownModule = "__unknownModule"
  val nodeJsBuiltInGlobalNames =
    Set(
      "assert",
      "buffer",
      "cluster",
      "crypto",
      "dgram",
      "dns",
      "domain",
      "events",
      "fs",
      "http",
      "https",
      "net",
      "os",
      "path",
      "punycode",
      "querystring",
      "readline",
      "repl",
      "stream",
      "string_decoder",
      "tls",
      "tty",
      "url",
      "util",
      "v8",
      "vm",
      "zlib",
      "process",
      "console",
      "document",
      "Buffer",
      "eval",
      "Buffer",
      "child_process",
      unknownModule,
      "crypto"
    )

  def isLibraryGlobalName(name: String): Boolean = {
    nodeJsBuiltInGlobalNames.exists(globalName => name.startsWith(globalName))
  }

  def asLibraryAPIName(globalBaseName: String, receiverFuncName: String): Option[String] = {
    if (globalBaseName == WALAGlobalContext) {
      if (nodeJsBuiltInGlobalNames.contains(receiverFuncName)) {
        return Some(receiverFuncName)
      }
    }
    if (isLibraryGlobalName(globalBaseName)) {
      return Some(globalBaseName + "." + receiverFuncName)
    }
    None
  }

  def primBinaryOpName(operator: IBinaryOpInstruction.IOperator): String =
    operator match {
      case op: CAstBinaryOp =>
        op match {
          case CAstBinaryOp.CONCAT    => "+"
          case CAstBinaryOp.EQ        => "=="
          case CAstBinaryOp.NE        => "!="
          case CAstBinaryOp.LT        => "<"
          case CAstBinaryOp.GE        => ">="
          case CAstBinaryOp.GT        => ">"
          case CAstBinaryOp.LE        => "<="
          case CAstBinaryOp.STRICT_EQ => "==="
          case CAstBinaryOp.STRICT_NE => "!=="
        }
      case IBinaryOpInstruction.Operator.ADD => "+"
      case IBinaryOpInstruction.Operator.SUB => "-"
      case IBinaryOpInstruction.Operator.MUL => "*"
      case IBinaryOpInstruction.Operator.DIV => "/"
      case IBinaryOpInstruction.Operator.REM => "%"
      case IBinaryOpInstruction.Operator.AND => "&"
      case IBinaryOpInstruction.Operator.OR  => "|"
      case IBinaryOpInstruction.Operator.XOR => "^"
    }

  def primUnaryOpName(operator: IUnaryOpInstruction.IOperator): String = {
    operator match {
      case op: CAstUnaryOp =>
        op match {
          case CAstUnaryOp.MINUS  => "-"
          case CAstUnaryOp.BITNOT => "!"
          case CAstUnaryOp.PLUS   => "+"
        }
      case IUnaryOpInstruction.Operator.NEG => "-"
    }
  }

  val moduleFieldNames = Set("_compile", "exports")

  /** Point to global context https://sourceforge.net/p/wala/mailman/message/32491808/
    */
  val WALAGlobalContext = "__WALA__int3rnal__global"

  private val constructorAPIs =
    Map("createElement" -> "HTMLElement", "createDecipher" -> "CryptoDecipher", "toString" -> "String", "execSync" -> "Byte[]")

  /** Whether a function is a API that is essentially an instance constructor
    *
    * If so, we will construct a API instance node during DFA for its return value.
    *
    * FIXME: Consider other APIs as well as the base namespace
    *
    * @return class name
    */
  def getConstructorAPI(funcName: String): Option[String] = constructorAPIs.get(funcName)

  val debug: Option[String] = sys.env.get("DEBUG")

  def isApplicationClassName(className: String): Boolean =
    !className.startsWith("LFakeRoot") &&
      !className.startsWith("Lprologue.js") &&
      !className.startsWith("Lextended-prologue.js") &&
      !className.startsWith("LObject")

  private val libPkgNames = Set("prologue.js", "extended-prologue.js")
  def isLibraryPkgName(pkgName: String): Boolean = libPkgNames.contains(pkgName)

  /** Decide whether a CGNode is a node in application code
    *
    * Some of the CGNodes are generated by analyzer to represent library dependencies etc.
    */
  def isApplicationNode(node: CGNode): Boolean = {
    node.getMethod match {
      case constructor: JavaScriptConstructorFunctions.JavaScriptConstructor =>
        val pkgName = constructor.constructedType().getName.getPackage
        if (pkgName == null) {
          return false
        }
        if (Constants.isLibraryPkgName(pkgName.toString)) {
          return false
        }
        return true
      case _ =>
    }
    Constants.isApplicationClassName(node.getMethod.getDeclaringClass.getName.toString)
  }

  def getIRofCG(cg: CallGraph): String = {
    val appNodes = cg.stream().filter(isApplicationNode).iterator().asScala.toList
    val appNodeSuccs = appNodes.flatMap(n => cg.getSuccNodes(n).asScala.filterNot(Constants.isApplicationNode))
    (appNodes ++ appNodeSuccs).map(_.getIR.toString).mkString("\n\n")
  }

  type NodeAttrs = Map[JsNodeAttr.Value, String]
  type GraphWriter = GexfWriter[JsNodeAttr.Value, JsEdgeAttr.Value]
}
